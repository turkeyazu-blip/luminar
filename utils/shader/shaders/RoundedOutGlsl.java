package ru.luminar.utils.shader.shaders;

import ru.luminar.utils.shader.IShader;

public class RoundedOutGlsl implements IShader {
   public String glsl() {
      return "#version 120\n// объявление переменных\nuniform vec2 size; // размер прямоугольника\nuniform vec4 round; // коэффициенты скругления углов\nuniform vec2 smoothness; // плавность перехода от цвета к прозрачности\nuniform float value; // значение, используемое для расчета расстояния до границы\nuniform vec4 color; // цвет прямоугольника\nuniform vec4 outlineColor; // цвет обводки\nuniform vec4 outlineColor1; // цвет обводки\nuniform vec4 outlineColor2; // цвет обводки\nuniform vec4 outlineColor3; // цвет обводки\nuniform float outline; // цвет обводки\n#define NOISE .5/255.0\n// функция для расчета расстояния до границы\nfloat test(vec2 vec_1, vec2 vec_2, vec4 vec_4) {\n    vec_4.xy = (vec_1.x > 0.0) ? vec_4.xy : vec_4.zw;\n    vec_4.x = (vec_1.y > 0.0) ? vec_4.x : vec_4.y;\n    vec2 coords = abs(vec_1) - vec_2 + vec_4.x;\n    return min(max(coords.x, coords.y), 0.0) + length(max(coords, vec2(0.0f))) - vec_4.x;\n}\n\nvec4 createGradient(vec2 coords, vec4 color1, vec4 color2, vec4 color3, vec4 color4) {\n    vec4 color = mix(mix(color1, color2, coords.y), mix(color3, color4, coords.y), coords.x);\n    //Dithering the color\n    // from https://shader-tutorial.dev/advanced/color-banding-dithering/\n    color += mix(NOISE, -NOISE, fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453));\n    return color;\n}\n\nvoid main() {\n    vec2 st = gl_TexCoord[0].st * size; // координаты текущего пикселя\n    vec2 halfSize = 0.5 * size; // половина размера прямоугольника\n    float sa = 1.0 - smoothstep(smoothness.x, smoothness.y, test(halfSize - st, halfSize - value, round));\n    float outline = 1.0 - smoothstep(smoothness.x, smoothness.y, test(halfSize - st, halfSize - value - outline, round));\n    float outlin1 = 1.0 - smoothstep(smoothness.x, smoothness.y, test(halfSize - st, halfSize - value - 1, round));\n\n    // рассчитываем прозрачность в зависимости от расстояния до границы\n    vec4 finalColor = mix(vec4(color.rgb, 0.0), vec4(color.rgb, color.a), sa); // устанавливаем цвет прямоугольника с прозрачностью sa\n\n    // если sa и outline равны, то это обводка\n    if (sa > outline) {\n        vec4 color = createGradient(gl_TexCoord[0].st, outlineColor, outlineColor1,outlineColor2,outlineColor3);\n        finalColor = vec4(color.r,color.g,color.b,outlin1); // присваиваем обводке ее цвет\n    }\n\n    gl_FragColor = finalColor;\n}\n";
   }
}
